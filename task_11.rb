# frozen_string_literal: true

# Клавиатура имеет следующую раскладку:

# ┌───┬───┬───┐
# │ 1 │ 2 │ 3 │
# ├───┼───┼───┤
# │ 4 │ 5 │ 6 │
# ├───┼───┼───┤
# │ 7 │ 8 │ 9 │
# └───┼───┼───┘
#     │ 0 │
#     └───┘
#
# В PIN-коде каждая из цифр может быть другой соседней цифрой (по горизонтали или вертикали, но не по диагонали).
# Например. вместо 1 это также может быть 2 или 4. И вместо 5 это также может быть 2, 4, 6 или 8.

# * возможно в смысле: самого наблюдаемого ПИН-кода и всех его вариаций с учетом соседних цифр.

# Напишите функцию возвращающую массив всех вариантов наблюдаемого PIN-кода длиной от 1 до 8 цифр. Но обратите внимание,
#  что все ПИН-коды, как наблюдаемый, так и результаты, должны быть строками, поскольку потенциально могут начинаться
#  с нулей.

ADJACENT = {
  '1' => %w[1 2 4],
  '2' => %w[1 2 3 5],
  '3' => %w[2 3 6],
  '4' => %w[1 4 5 7],
  '5' => %w[2 4 5 6 8],
  '6' => %w[3 5 6 9],
  '7' => %w[4 7 8 0],
  '8' => %w[5 7 8 9 0],
  '9' => %w[6 8 9],
  '0' => %w[0 8]
}

def get_pins(observed)
  generate_pins = lambda do |observed, current_pin|
    return [current_pin] if current_pin.length == observed.length

    ADJACENT[observed[current_pin.length]].flat_map do |next_digit|
      generate_pins.call(observed, current_pin + next_digit)
    end
  end

  generate_pins.call(observed, '')
end
